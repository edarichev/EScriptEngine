/**
 * AUTOGENERATED
 * @file assembler.cpp
 * @date 02.08.2023 21:28:26
 * @brief Для записи инструкций в объектный файл
 */
#include "stdafx.h"
#include "assembler.h"

namespace escript {

// мнемоники
const std::string Assembler::_opCodeNames[] = {
    "NOP", "HALT", "MOV A, DATA64", "MOV B, DATA64", 
    "LD64 A, M", "ST64 M, A", "ADI A, B", "IMUL A, B", 
    
};
// все коды операций
OpCode Assembler::_opCodes[] = {
    OpCode::NOP, OpCode::HALT, OpCode::MOV_A_DATA64, OpCode::MOV_B_DATA64, 
    OpCode::LD64_A_M, OpCode::ST64_M_A, OpCode::ADI_A_B, OpCode::IMUL_A_B, 
    
};
// размер в байтах каждой команды
uint8_t Assembler::_opCodeSize[] = {
    1, 1, 9, 9, 
    9, 9, 1, 1, 
    
};
// ключ - код операции, значение - индекс в массивах
std::map<OpCode, int> Assembler::_opCodesMap;


const std::string &Assembler::mnemonics(OpCode opCode)
{
    auto it = _opCodesMap.find(opCode);
    if (it == _opCodesMap.end())
        throw std::out_of_range("Unknown OpCode");
    return _opCodeNames[it->second];
}

uint8_t Assembler::instructionSize(OpCode opCode)
{
    auto it = _opCodesMap.find(opCode);
    if (it == _opCodesMap.end())
        throw std::out_of_range("Unknown OpCode");
    return _opCodeSize[it->second];
}

void Assembler::initOpCodesMap()
{
    if (!_opCodesMap.empty())
        return;
    for (int i = 0; i < (int)(sizeof (_opCodes) / sizeof (OpCode)); i++) {
        _opCodesMap[_opCodes[i]] = i;
    }
}

} // namespace escript
