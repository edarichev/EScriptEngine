/**
 * AUTOGENERATED
 * @file assembler.cpp
 * @date 03.08.2023 22:34:34
 * @brief Для записи инструкций в объектный файл
 */
#include "stdafx.h"
#include "assembler.h"

namespace escript {

// мнемоники
const std::string Assembler::_opCodeNames[] = {
    "NOP", "HALT", "MOV A, DATA64", "MOV B, DATA64", 
    "LD64 A, M", "ST64 M, A", "ADI A, B", "IMUL A, B", 
    "LDC.UINT64 DATA64", "LDC.INT64 DATA64", "LDLOC M", "LDC.DOUBLE DATA64", 
    "ADDST", "MULST", "POP A", "CMP A, D64", 
    "STLOC M", "NEG", 
};
// все коды операций
OpCode Assembler::_opCodes[] = {
    OpCode::NOP, OpCode::HALT, OpCode::MOV_A_DATA64, OpCode::MOV_B_DATA64, 
    OpCode::LD64_A_M, OpCode::ST64_M_A, OpCode::ADI_A_B, OpCode::IMUL_A_B, 
    OpCode::LDC_UINT64_DATA64, OpCode::LDC_INT64_DATA64, OpCode::LDLOC_M, OpCode::LDC_DOUBLE_DATA64, 
    OpCode::ADDST, OpCode::MULST, OpCode::POP_A, OpCode::CMP_A_D64, 
    OpCode::STLOC_M, OpCode::NEG, 
};
// размер в байтах каждой команды
uint8_t Assembler::_opCodeSize[] = {
    1, 1, 9, 9, 
    9, 9, 1, 1, 
    9, 9, 9, 9, 
    1, 1, 1, 9, 
    9, 1, 
};
// ключ - код операции, значение - индекс в массивах
std::map<OpCode, int> Assembler::_opCodesMap;


const std::string &Assembler::mnemonics(OpCode opCode)
{
    auto it = _opCodesMap.find(opCode);
    if (it == _opCodesMap.end())
        throw std::out_of_range("Unknown OpCode");
    return _opCodeNames[it->second];
}

uint8_t Assembler::instructionSize(OpCode opCode)
{
    auto it = _opCodesMap.find(opCode);
    if (it == _opCodesMap.end())
        throw std::out_of_range("Unknown OpCode");
    return _opCodeSize[it->second];
}

void Assembler::initOpCodesMap()
{
    if (!_opCodesMap.empty())
        return;
    for (int i = 0; i < (int)(sizeof (_opCodes) / sizeof (OpCode)); i++) {
        _opCodesMap[_opCodes[i]] = i;
    }
}

void Assembler::disassemble(const std::vector<ContainerElementType> &objectFile, std::ostream &out)
{
    size_t i = 0;
    const uint8_t *p = objectFile.data();
    // пропустить 4 байта "DATA"
    uint32_t dataLength = *(uint32_t*)(p + 4);
    i = 4 + 4 + dataLength + 4; // 4=DATA + dataLength + 4=CODE
    uint32_t codeLength = *(uint32_t*)(p + i);
    i += sizeof (codeLength);
    size_t n = i + codeLength;
    while (i < n) {
        // читаем команду
        OpCodeType opCodeType = *(OpCodeType*)(p + i);
        OpCode opCode = (OpCode)opCodeType;
        uint8_t instrSize = instructionSize(opCode);
        i += instrSize;
        out << mnemonics(opCode) << std::endl;
    }
    assert (n == i);
}

} // namespace escript
