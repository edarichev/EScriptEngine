/**
 * AUTOGENERATED
 * @file assembler_test.cpp
 * @date 02.08.2023 21:28:26
 * @brief Тестирование записи инструкций в объектный файл
 */
#include "stdafx.h"
#include "assembler_test.h"
#include "assembler.h"

using namespace escript;
using namespace std;

void Assembler_Test::run()
{
    initTestCase();
    test_byteSequence();
    cleanupTestCase();
}

void Assembler_Test::initTestCase()
{

}

void Assembler_Test::cleanupTestCase()
{

}

void Assembler_Test::test_byteSequence()
{
    // проверяется корректность записи в память, никаких вычислений

    // буфер - объектный файл
    std::vector<uint8_t> obj;
    Assembler a(obj);
    // переменные для теста записи
    uint64_t value64 = 0;
    //uint64_t value32 = 0;
    //uint64_t value16 = 0;
    //uint64_t value8 = 0;

    // указатели для чтения
    uint8_t *p = nullptr;
    // сдвиг от начала буфера - счётчик, т.к. указательнельзя двигать просто так
    // т.к. буфер может перевыделяться, поэтому для доступа к буферу нужно
    // присвоить указатель "p" после выполнения команды
    size_t n = 0;


    a.nop();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::NOP);
    assert(*((Assembler::OpCodeType *)p) == (Assembler::OpCodeType)OpCode::NOP);
    assert(obj.size() == n);
    
    a.halt();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::HALT);
    assert(*((Assembler::OpCodeType *)p) == (Assembler::OpCodeType)OpCode::HALT);
    assert(obj.size() == n);
    
    value64 = rand();
    a.mov_a_data64(value64);
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::MOV_A_DATA64);
    assert(*p == (Assembler::OpCodeType)OpCode::MOV_A_DATA64);
    p += Assembler::INSTRUCTION_CODE_SIZE;
    assert(*((uint64_t *)p) == value64);
    assert(obj.size() == n);
    
    value64 = rand();
    a.mov_b_data64(value64);
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::MOV_B_DATA64);
    assert(*p == (Assembler::OpCodeType)OpCode::MOV_B_DATA64);
    p += Assembler::INSTRUCTION_CODE_SIZE;
    assert(*((uint64_t *)p) == value64);
    assert(obj.size() == n);
    
    value64 = rand();
    a.ld64_a_m(value64);
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::LD64_A_M);
    assert(*p == (Assembler::OpCodeType)OpCode::LD64_A_M);
    p += Assembler::INSTRUCTION_CODE_SIZE;
    assert(*((uint64_t *)p) == value64);
    assert(obj.size() == n);
    
    value64 = rand();
    a.st64_m_a(value64);
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::ST64_M_A);
    assert(*p == (Assembler::OpCodeType)OpCode::ST64_M_A);
    p += Assembler::INSTRUCTION_CODE_SIZE;
    assert(*((uint64_t *)p) == value64);
    assert(obj.size() == n);
    
    a.adi_a_b();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::ADI_A_B);
    assert(*((Assembler::OpCodeType *)p) == (Assembler::OpCodeType)OpCode::ADI_A_B);
    assert(obj.size() == n);
    
    a.imul_a_b();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::IMUL_A_B);
    assert(*((Assembler::OpCodeType *)p) == (Assembler::OpCodeType)OpCode::IMUL_A_B);
    assert(obj.size() == n);
    
}
