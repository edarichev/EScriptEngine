/**
 * AUTOGENERATED
 * @file assembler_test.cpp
 * @date 28.08.2023 12:42:05
 * @brief Тестирование записи инструкций в объектный файл
 */
#include "stdafx.h"
#include "assembler_test.h"
#include "assembler.h"

using namespace escript;
using namespace std;

void Assembler_Test::run()
{
    initTestCase();
    test_byteSequence();
    cleanupTestCase();
}

void Assembler_Test::initTestCase()
{

}

void Assembler_Test::cleanupTestCase()
{

}

void Assembler_Test::test_byteSequence()
{
    // проверяется корректность записи в память, никаких вычислений

    // буфер - объектный файл
    std::vector<uint8_t> obj;
    Assembler a(obj);
    // переменные для теста записи
    uint64_t uint64_t_value = 0;
    int64_t int64_t_value = 0;
    double double_value = 0;
    //uint32_t uint32_t_value32 = 0;
    //uint16_t uint16_t_value = 0;
    uint8_t uint8_t_value = 0;

    // указатели для чтения
    uint8_t *p = nullptr;
    // сдвиг от начала буфера - счётчик, т.к. указатель нельзя двигать просто так
    // т.к. буфер может перевыделяться, поэтому для доступа к буферу нужно
    // присвоить указатель "p" после выполнения команды
    size_t n = 0;


    a.nop();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::NOP);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::NOP);
    assert(obj.size() == n);
    
    a.halt();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::HALT);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::HALT);
    assert(obj.size() == n);
    
    uint64_t_value = rand();
    a.ldc_uint64_data64(uint64_t_value);
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::LDC_UINT64_DATA64);
    assert(*p == (OpCodeType)OpCode::LDC_UINT64_DATA64);
    p += Assembler::INSTRUCTION_CODE_SIZE;
    assert(*((uint64_t *)p) == uint64_t_value);
    assert(obj.size() == n);
    
    int64_t_value = rand();
    a.ldc_int64_data64(int64_t_value);
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::LDC_INT64_DATA64);
    assert(*p == (OpCodeType)OpCode::LDC_INT64_DATA64);
    p += Assembler::INSTRUCTION_CODE_SIZE;
    assert(*((int64_t *)p) == int64_t_value);
    assert(obj.size() == n);
    
    uint64_t_value = rand();
    a.ldloc_m(uint64_t_value);
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::LDLOC_M);
    assert(*p == (OpCodeType)OpCode::LDLOC_M);
    p += Assembler::INSTRUCTION_CODE_SIZE;
    assert(*((uint64_t *)p) == uint64_t_value);
    assert(obj.size() == n);
    
    double_value = rand();
    a.ldc_double_data64(double_value);
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::LDC_DOUBLE_DATA64);
    assert(*p == (OpCodeType)OpCode::LDC_DOUBLE_DATA64);
    p += Assembler::INSTRUCTION_CODE_SIZE;
    assert(*((double *)p) == double_value);
    assert(obj.size() == n);
    
    a.addst();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::ADDST);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::ADDST);
    assert(obj.size() == n);
    
    a.mulst();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::MULST);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::MULST);
    assert(obj.size() == n);
    
    a.divst();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::DIVST);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::DIVST);
    assert(obj.size() == n);
    
    a.subst();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::SUBST);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::SUBST);
    assert(obj.size() == n);
    
    uint64_t_value = rand();
    a.stloc_m(uint64_t_value);
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::STLOC_M);
    assert(*p == (OpCodeType)OpCode::STLOC_M);
    p += Assembler::INSTRUCTION_CODE_SIZE;
    assert(*((uint64_t *)p) == uint64_t_value);
    assert(obj.size() == n);
    
    a.neg();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::NEG);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::NEG);
    assert(obj.size() == n);
    
    uint64_t_value = rand();
    a.jmp_m(uint64_t_value);
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::JMP_M);
    assert(*p == (OpCodeType)OpCode::JMP_M);
    p += Assembler::INSTRUCTION_CODE_SIZE;
    assert(*((uint64_t *)p) == uint64_t_value);
    assert(obj.size() == n);
    
    uint8_t_value = rand();
    a.ldc_bool_data8(uint8_t_value);
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::LDC_BOOL_DATA8);
    assert(*p == (OpCodeType)OpCode::LDC_BOOL_DATA8);
    p += Assembler::INSTRUCTION_CODE_SIZE;
    assert(*((uint8_t *)p) == uint8_t_value);
    assert(obj.size() == n);
    
    uint64_t_value = rand();
    a.iffalse_m(uint64_t_value);
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::IFFALSE_M);
    assert(*p == (OpCodeType)OpCode::IFFALSE_M);
    p += Assembler::INSTRUCTION_CODE_SIZE;
    assert(*((uint64_t *)p) == uint64_t_value);
    assert(obj.size() == n);
    
    a.stless();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::STLESS);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::STLESS);
    assert(obj.size() == n);
    
    a.stless_eq();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::STLESS_EQ);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::STLESS_EQ);
    assert(obj.size() == n);
    
    a.stgt();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::STGT);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::STGT);
    assert(obj.size() == n);
    
    a.stgt_eq();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::STGT_EQ);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::STGT_EQ);
    assert(obj.size() == n);
    
    a.steq();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::STEQ);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::STEQ);
    assert(obj.size() == n);
    
    a.ldargs();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::LDARGS);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::LDARGS);
    assert(obj.size() == n);
    
    a.ret();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::RET);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::RET);
    assert(obj.size() == n);
    
    uint64_t_value = rand();
    a.call(uint64_t_value);
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::CALL);
    assert(*p == (OpCodeType)OpCode::CALL);
    p += Assembler::INSTRUCTION_CODE_SIZE;
    assert(*((uint64_t *)p) == uint64_t_value);
    assert(obj.size() == n);
    
    uint64_t_value = rand();
    a.ldstring(uint64_t_value);
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::LDSTRING);
    assert(*p == (OpCodeType)OpCode::LDSTRING);
    p += Assembler::INSTRUCTION_CODE_SIZE;
    assert(*((uint64_t *)p) == uint64_t_value);
    assert(obj.size() == n);
    
    a.callm();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::CALLM);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::CALLM);
    assert(obj.size() == n);
    
    uint64_t_value = rand();
    a.allocarray(uint64_t_value);
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::ALLOCARRAY);
    assert(*p == (OpCodeType)OpCode::ALLOCARRAY);
    p += Assembler::INSTRUCTION_CODE_SIZE;
    assert(*((uint64_t *)p) == uint64_t_value);
    assert(obj.size() == n);
    
    a.inc();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::INC);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::INC);
    assert(obj.size() == n);
    
    a.dec();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::DEC);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::DEC);
    assert(obj.size() == n);
    
    a.pop();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::POP);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::POP);
    assert(obj.size() == n);
    
    a.rsh();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::RSH);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::RSH);
    assert(obj.size() == n);
    
    a.rshz();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::RSHZ);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::RSHZ);
    assert(obj.size() == n);
    
    a.lsh();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::LSH);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::LSH);
    assert(obj.size() == n);
    
    a.bit_and();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::BIT_AND);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::BIT_AND);
    assert(obj.size() == n);
    
    a.bit_or();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::BIT_OR);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::BIT_OR);
    assert(obj.size() == n);
    
    a.bit_xor();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::BIT_XOR);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::BIT_XOR);
    assert(obj.size() == n);
    
    a.log_and();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::LOG_AND);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::LOG_AND);
    assert(obj.size() == n);
    
    a.log_or();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::LOG_OR);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::LOG_OR);
    assert(obj.size() == n);
    
    a.bit_not();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::BIT_NOT);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::BIT_NOT);
    assert(obj.size() == n);
    
    a.log_not();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::LOG_NOT);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::LOG_NOT);
    assert(obj.size() == n);
    
    a.modst();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::MODST);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::MODST);
    assert(obj.size() == n);
    
    uint64_t_value = rand();
    a.st_ar(uint64_t_value);
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::ST_AR);
    assert(*p == (OpCodeType)OpCode::ST_AR);
    p += Assembler::INSTRUCTION_CODE_SIZE;
    assert(*((uint64_t *)p) == uint64_t_value);
    assert(obj.size() == n);
    
    uint64_t_value = rand();
    a.ld_ar(uint64_t_value);
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::LD_AR);
    assert(*p == (OpCodeType)OpCode::LD_AR);
    p += Assembler::INSTRUCTION_CODE_SIZE;
    assert(*((uint64_t *)p) == uint64_t_value);
    assert(obj.size() == n);
    
    a.ld_null();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::LD_NULL);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::LD_NULL);
    assert(obj.size() == n);
    
    a.stnoteq();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::STNOTEQ);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::STNOTEQ);
    assert(obj.size() == n);
    
    a.stnco();
    p = obj.data() + n;
    n += Assembler::instructionSize(OpCode::STNCO);
    assert(*((OpCodeType *)p) == (OpCodeType)OpCode::STNCO);
    assert(obj.size() == n);
    
}
