/**
 * AUTOGENERATED
 * @file assembler.h
 * @date $(Date)
 * @brief Для записи инструкций в объектный файл
 */
#ifndef ASSEMBLER_H
#define ASSEMBLER_H

#include "EScript_global.h"
#include <vector>
#include "opcode.h"

namespace escript {

/**
 * @brief Записывает инструкции в объектный файл
 */
class ESCRIPT_EXPORT Assembler
{
public:
    using ContainerElementType = uint8_t;
    using OpCodeType = $(OpCodeEnumDataType);
private:
    // буфер для записи (объектный файл)
    std::vector<ContainerElementType> &_buffer;
    // мнемоники
    static const std::string _opCodeNames[];
    // все коды операций
    static OpCode _opCodes[];
    // размер в байтах каждой команды
    static uint8_t _opCodeSize[];
    // ключ - код операции, значение - индекс в массивах
    static std::map<OpCode, int> _opCodesMap;
public:
    /**
     * @brief Размер кода машинной инструкции
     */
    static const constexpr int INSTRUCTION_CODE_SIZE = sizeof (OpCodeType);
public:
    /**
     * @brief Создаёт новый экземпляр класса Assembler
     */
    Assembler(std::vector<ContainerElementType> &buffer): _buffer(buffer)
    {
        initOpCodesMap();
    }
    // Доступ  командам и мнемоникам
public:
    /**
     * @brief Возвращает мнемонику команды
     * @param opCode код операции
     * @return мнемоника, например, "MOV A, B"
     */
    static const std::string &mnemonics(OpCode opCode);

    /**
     * @brief Возвращает размер команды в байтах
     * @param opCode код операции
     * @return зависит от числа и размера операндов
     */
    static uint8_t instructionSize(OpCode opCode);

    /**
     * @brief Дизассемблирует объектный файл
     * @param objectFile объектный файл
     * @param out поток вывода, например, std::cout
     */
    static void disassemble(const std::vector<ContainerElementType> &objectFile, std::ostream &out);

    // Команды. Код и операнды записываются в буфер памяти
public:
$(CommandList)
private:
    /**
     * @brief Операция с одним только кодом
     * @param opCode код операции
     */
    void op1(OpCode opCode)
    {
        _buffer.insert(_buffer.end(),
                       (uint8_t*)&opCode,
                       (uint8_t*)&opCode + sizeof (OpCode));
    }
    /**
     * @brief Операция с двумя частями: код операции и операнд
     * @param opCode код операции
     * @param data операнд
     */
    template<typename T>
    typename std::enable_if_t<std::is_arithmetic_v<T>, void>
    op2(OpCode opCode, T data)
    {
        op1(opCode);                  // код операции
        _buffer.insert(_buffer.end(), // записываем операнд
                       (uint8_t*)&data,
                       (uint8_t*)&data + sizeof (T));
    }
private:
    /**
     * @brief Заполняет хэш-таблицу с индексами кодов операций
     */
    static void initOpCodesMap();
};

} // namespace escript
#endif // ASSEMBLER_H
