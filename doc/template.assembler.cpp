/**
 * AUTOGENERATED
 * @file assembler.cpp
 * @date $(Date)
 * @brief Для записи инструкций в объектный файл
 */
#include "stdafx.h"
#include "assembler.h"

namespace escript {

// мнемоники
const std::string Assembler::_opCodeNames[] = {
    $(OpCodeNamesList)
};
// все коды операций
OpCode Assembler::_opCodes[] = {
    $(OpCodesList)
};
// размер в байтах каждой команды
uint8_t Assembler::_opCodeSize[] = {
    $(OpCodesSizeList)
};
// ключ - код операции, значение - индекс в массивах
std::map<OpCode, int> Assembler::_opCodesMap;


const std::string &Assembler::mnemonics(OpCode opCode)
{
    auto it = _opCodesMap.find(opCode);
    if (it == _opCodesMap.end())
        throw std::out_of_range("Unknown OpCode");
    return _opCodeNames[it->second];
}

uint8_t Assembler::instructionSize(OpCode opCode)
{
    auto it = _opCodesMap.find(opCode);
    if (it == _opCodesMap.end())
        throw std::out_of_range("Unknown OpCode");
    return _opCodeSize[it->second];
}

void Assembler::initOpCodesMap()
{
    if (!_opCodesMap.empty())
        return;
    for (int i = 0; i < (int)(sizeof (_opCodes) / sizeof (OpCode)); i++) {
        _opCodesMap[_opCodes[i]] = i;
    }
}

void Assembler::disassemble(const std::vector<ContainerElementType> &objectFile, std::ostream &out)
{
    size_t i = 0;
    const uint8_t *p = objectFile.data();
    // пропустить начальный JMP и 4 байта "DATA"
    uint32_t dataLength = *(uint32_t*)(p + 4 + Assembler::instructionSize(OpCode::JMP_M));
    i = Assembler::instructionSize(OpCode::JMP_M) +
            4 + 4 + dataLength + 4; // 4=DATA + dataLength + 4=CODE
    uint32_t codeLength = *(uint32_t*)(p + i);
    i += sizeof (codeLength);
    size_t n = i + codeLength;
    const char *fnMarker = "FUNC";
    while (i < n) {
        // читаем команду
        OpCodeType opCodeType = *(OpCodeType*)(p + i);
        OpCode opCode = (OpCode)opCodeType;
        try {
            uint8_t instrSize = instructionSize(opCode);
            i += instrSize;
            out << mnemonics(opCode) << std::endl;
        } catch (const std::out_of_range &e) {
            if (*(p + i) == 'F') {
                if (strncmp((char*)p + i, fnMarker, 4) == 0) {
                    i += 4;
                    int32_t dataLen = *(int32_t*)(p + i);
                    i += dataLen;
                    continue;
                }
            }
            throw;
        }
    }
    assert (n == i);
}

} // namespace escript
